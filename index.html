<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Drop Game</title>
<style>
body { margin:0; background:#000; display:flex; justify-content:center; align-items:center; min-height:100vh; flex-direction: column; font-family:system-ui, sans-serif; color:#fff; }
.game-wrapper{ background:#111; padding:12px; border-radius:20px; box-shadow:0 20px 40px rgba(0,0,0,0.5);}
canvas{ display:block; background:#000; border-radius:12px; }
.controls{ display:flex; justify-content:center; gap:12px; margin-top:8px;}
button{ cursor:pointer;}
.control-btn{ width:64px; height:64px; border-radius:50%; font-size:18px; background:#222; color:#fff; box-shadow:0 4px 0 #111; transition: transform 0.1s;}
.control-btn:active{ transform:translateY(4px);}
.control-btn.drop{ background:#ffb74d; color:#000;}
.icon-btn{ width:32px; height:32px; border-radius:50%; background:#222; color:#fff;}
.overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.8); display:flex; justify-content:center; align-items:center; z-index:100;}
.overlay-content{ background:#222; color:#fff; padding:24px; border-radius:16px; text-align:center; width:80%; max-width:300px;}
.primary{ background:#ffb74d; color:#000; padding:8px 16px; border-radius:8px; font-size:16px;}
.primary:active{ transform:translateY(2px);}
</style>
</head>
<body>

<div class="game-wrapper">
  <div class="top-bar">
    <div>Score: <span id="score">0</span></div>
    <div>⏱ <span id="time">180</span>s
      <button id="pauseBtn" class="icon-btn">⏸</button>
      <button id="restartBtn" class="icon-btn">⟳</button>
    </div>
  </div>
  <canvas id="game" width="240" height="480"></canvas>

  <div class="controls">
    <button id="leftBtn" class="control-btn">←</button>
    <button id="rotateBtn" class="control-btn">⟳</button>
    <button id="rightBtn" class="control-btn">→</button>
    <button id="dropBtn" class="control-btn drop">↓</button>
  </div>
</div>

<div id="overlay" class="overlay" style="display:none;">
  <div class="overlay-content">
    <h2 id="overlayTitle">Game Over</h2>
    <p>Score: <span id="finalScore">0</span></p>
    <button id="playAgainBtn" class="primary">もう一回プレイ</button>
  </div>
</div>

<div id="startOverlay" class="overlay">
  <div class="overlay-content">
    <h2>Mini Drop Game</h2>
    <button id="startBtn" class="primary">ゲーム開始</button>
  </div>
</div>

<script>
const COLS=6, ROWS=12, BLOCK_SIZE=40, TYPES=8;
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const scoreEl=document.getElementById('score');
const timeEl=document.getElementById('time');
const overlay=document.getElementById('overlay');
const finalScoreEl=document.getElementById('finalScore');
const overlayTitle=document.getElementById('overlayTitle');
const startOverlay=document.getElementById('startOverlay');
const startBtn=document.getElementById('startBtn');
const pauseBtn=document.getElementById('pauseBtn');

let grid, currentPair, score, timeLeft, paused=false;
let gameInterval, timerInterval, dropInterval;

// --- 画像読み込み ---
const blockImages = [];
for(let i=0;i<TYPES;i++){
  const img = new Image();
  img.src = `block${i+1}.png`;
  blockImages.push(img);
}

// 初期化
function init(){
  grid=Array.from({length:ROWS},()=>Array(COLS).fill(null));
  score=0; timeLeft=180; paused=false;
  scoreEl.textContent=score;
  timeEl.textContent=timeLeft;
  spawnPair();
  clearInterval(gameInterval);
  clearInterval(timerInterval);
  gameInterval=setInterval(gameLoop, 300);
  timerInterval=setInterval(()=>{
    if(!paused){
      timeLeft--;
      timeEl.textContent=timeLeft;
      if(timeLeft<=0) endGame('Time Up');
    }
  },1000);
}

// ペア生成
function spawnPair(){
  const col = 2;
  const first = randType();
  const second = randType();
  currentPair = { x:col, y:0, dir:0, blocks:[first, second] };
  if(!canMove(currentPair.x, currentPair.y, currentPair.dir)) endGame('Game Over');
}

function randType(){ return Math.floor(Math.random()*TYPES); }

// ペア座標取得（4方向回転対応）
function getPairPositions(x, y, dir){
  switch(dir){
    case 0: return [{x:x, y:y}, {x:x, y:y+1}]; // 下
    case 1: return [{x:x, y:y}, {x:x+1, y:y}]; // 右
    case 2: return [{x:x, y:y}, {x:x, y:y-1}]; // 上
    case 3: return [{x:x, y:y}, {x:x-1, y:y}]; // 左
  }
}

// 移動可能か
function canMove(x,y,dir){
  return getPairPositions(x,y,dir).every(p=>p.x>=0 && p.x<COLS && p.y<ROWS && (p.y<0 || grid[p.y][p.x]===null));
}

// 移動
function move(dx,dy){
  if(currentPair && canMove(currentPair.x+dx,currentPair.y+dy,currentPair.dir)){
    currentPair.x+=dx; currentPair.y+=dy;
    return true;
  }
  return false;
}

// 回転（4方向）
function rotate(){
  if(!currentPair) return;
  const newDir = (currentPair.dir + 1) % 4;
  if(canMove(currentPair.x, currentPair.y, newDir)){
    currentPair.dir = newDir;
  }
}

// ペア固定
function fixPair(){
  getPairPositions(currentPair.x,currentPair.y,currentPair.dir).forEach((p,i)=>{
    if(p.y>=0) grid[p.y][p.x] = currentPair.blocks[i];
  });
  currentPair = null;
}

// 個別落下
function applyGravityIndividual(){
  for(let x=0;x<COLS;x++){
    for(let y=ROWS-2;y>=0;y--){
      if(grid[y][x]!==null && grid[y+1][x]===null){
        grid[y+1][x]=grid[y][x];
        grid[y][x]=null;
      }
    }
  }
}

// マッチ判定
function checkMatches(){
  const visited=Array.from({length:ROWS},()=>Array(COLS).fill(false));
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x]===null || visited[y][x]) continue;
      const type = grid[y][x];
      const stack=[{x,y}], group=[];
      while(stack.length){
        const p = stack.pop(); if(visited[p.y][p.x]) continue;
        visited[p.y][p.x] = true; group.push(p);
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
          const nx=p.x+dx, ny=p.y+dy;
          if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&!visited[ny][nx]&&grid[ny][nx]===type)
            stack.push({x:nx,y:ny});
        });
      }
      if(group.length>=3){ group.forEach(p=>grid[p.y][p.x]=null); score+=group.length*10; }
    }
  }
  scoreEl.textContent = score;
}

// 描画
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 固定ブロック
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const t = grid[y][x];
      if(t!==null && blockImages[t]) ctx.drawImage(blockImages[t], x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }
  }
  // 落下中ペア
  if(currentPair){
    getPairPositions(currentPair.x,currentPair.y,currentPair.dir).forEach((p,i)=>{
      if(p.y>=0 && blockImages[currentPair.blocks[i]]) 
        ctx.drawImage(blockImages[currentPair.blocks[i]], p.x*BLOCK_SIZE, p.y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    });
  }
}

// ゲームループ
function gameLoop(){
  if(paused) return;
  if(!move(0,1)){
    fixPair();
    checkMatches();
    spawnPair();
  }
  applyGravityIndividual();
  draw();
}

// 終了
function endGame(title){
  clearInterval(gameInterval);
  clearInterval(timerInterval);
  overlayTitle.textContent = title;
  finalScoreEl.textContent = score;
  overlay.style.display='flex';
}

// 長押し落下
const dropBtn = document.getElementById('dropBtn');
dropBtn.addEventListener('mousedown', ()=>{ move(0,1); dropInterval=setInterval(()=>move(0,1),50); });
dropBtn.addEventListener('mouseup', ()=>clearInterval(dropInterval));
dropBtn.addEventListener('mouseleave', ()=>clearInterval(dropInterval));

// ボタン操作
document.getElementById('leftBtn').onclick=()=>move(-1,0);
document.getElementById('rightBtn').onclick=()=>move(1,0);
document.getElementById('rotateBtn').onclick=rotate;
document.getElementById('restartBtn').onclick=init;
document.getElementById('playAgainBtn').onclick=()=>{ overlay.style.display='none'; init(); };

// 一時停止
pauseBtn.onclick=()=>{ paused=!paused; pauseBtn.textContent = paused?'▶︎':'⏸'; };

// キーボード操作
document.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft') move(-1,0);
  if(e.key==='ArrowRight') move(1,0);
  if(e.key==='ArrowDown') move(0,1);
  if(e.key==='ArrowUp') rotate();
});

// スタート
startBtn.onclick=()=>{ startOverlay.style.display='none'; init(); };
</script>
</body>
</html>

